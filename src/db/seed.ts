import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import { faker } from "@faker-js/faker";
import "dotenv/config";

// Individual Schema Imports (pointing to your files)
import { usersTable } from "./schema/users.js";
import { postsTable } from "./schema/posts.js";
import { commentsTable } from "./schema/comments.js";
import { tagsTable, postTagsTable } from "./schema/tags.js";
import { postLikesTable } from "./schema/post-likes.js";
import { postViewsTable } from "./schema/post-views.js";
import { refreshTokensTable } from "./schema/tokens.js";
import { generateSlug } from "@/utils/slug.js";

const sql = neon(process.env.DATABASE_URL!);

// Combine them into a single schema object for Drizzle
const db = drizzle(sql, {
  schema: {
    usersTable,
    postsTable,
    commentsTable,
    tagsTable,
    postTagsTable,
    postLikesTable,
    postViewsTable,
    refreshTokensTable,
  },
});

const generateMarkdown = () => `
# ${faker.lorem.sentence()}
${faker.lorem.paragraphs(1)}

## ${faker.lorem.words(3)}
* ${faker.lorem.sentence()}
* ${faker.lorem.sentence()}

\`\`\`javascript
console.log("${faker.lorem.word()}");
\`\`\`

> ${faker.lorem.sentence()}
`;

async function main() {
  console.log("Emptying existing data...");
  // Order matters: Children first, then Parents
  await db.delete(commentsTable);
  await db.delete(postTagsTable);
  await db.delete(tagsTable);
  await db.delete(postLikesTable);
  await db.delete(postViewsTable);
  await db.delete(refreshTokensTable);
  await db.delete(postsTable);
  await db.delete(usersTable);

  console.log("Seeding Users...");
  const users = await db
    .insert(usersTable)
    .values(
      Array.from({ length: 10 }).map(() => ({
        username: faker.internet.username().slice(0, 32),
        email: faker.internet.email(),
        passwordHash: "mock_password_hash",
        role: faker.helpers.arrayElement(["admin", "author", "user"] as const),
        bio: faker.lorem.sentence(),
      }))
    )
    .returning();

  console.log("Seeding Tags...");
  const tags = await db
    .insert(tagsTable)
    .values(
      ["React", "NodeJS", "Database", "TypeScript", "WebDev"].map((name) => ({
        name,
      }))
    )
    .returning();

  console.log("Seeding Posts...");
  const posts = [];
  const authors = users.filter((u) => u.role !== "user");

  for (const author of authors) {
    const title = faker.lorem.sentence();
    const userPosts = await db
      .insert(postsTable)
      .values(
        Array.from({ length: 3 }).map(() => ({
          authorId: author.id,
          title: title,
          slug: generateSlug(title),
          contentMarkdown: generateMarkdown(),
          status: "published" as const,
          publishedAt: faker.date.past(),
        }))
      )
      .returning();
    posts.push(...userPosts);
  }

  console.log("Seeding Relations & Interactions...");
  for (const post of posts) {
    // Tags
    const randomTags = faker.helpers.arrayElements(tags, { min: 1, max: 3 });
    await db
      .insert(postTagsTable)
      .values(randomTags.map((tag) => ({ postId: post.id, tagId: tag.id })));

    // Views
    await db.insert(postViewsTable).values(
      Array.from({ length: 5 }).map(() => ({
        postId: post.id,
        ipAddress: faker.internet.ip(),
        viewDate: new Date().toISOString().split("T")[0],
      }))
    );

    // Likes
    const likers = faker.helpers.arrayElements(users, { min: 1, max: 4 });
    await db
      .insert(postLikesTable)
      .values(likers.map((u) => ({ userId: u.id, postId: post.id })));

    // Comments
    const rootComments = await db
      .insert(commentsTable)
      .values(
        Array.from({ length: 2 }).map(() => ({
          authorId: faker.helpers.arrayElement(users).id,
          postId: post.id,
          content: faker.lorem.sentence(),
        }))
      )
      .returning();

    // One nested reply per post
    await db.insert(commentsTable).values({
      authorId: faker.helpers.arrayElement(users).id,
      postId: post.id,
      parentId: rootComments[0].id,
      content: "This is a nested reply generated by the seeder.",
    });
  }

  console.log("✅ Seeding completed successfully!");
}

main().catch((err) => {
  console.error("❌ Seeding failed!");
  console.error(err);
  process.exit(1);
});
